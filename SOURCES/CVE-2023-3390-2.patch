From bfc26ab77a8bdb3d2f8107f9ca33b49707e78746 Mon Sep 17 00:00:00 2001
From: Ryan Sullivan <rysulliv@redhat.com>
Date: Thu, 24 Aug 2023 10:27:39 -0400
Subject: [KPATCH 8.8] kpatch fixes for CVE-2023-3390

Kernels:
4.18.0-477.13.1.el8_8
4.18.0-477.15.1.el8_8
4.18.0-477.21.1.el8_8

Changes since last build:
[x86_64]:
cls_flower.o: changed function: fl_set_geneve_opt
cls_fw.o: changed function: fw_set_parms
ipvlan_core.o: changed function: ipvlan_process_v6_outbound
ipvlan_core.o: changed function: ipvlan_queue_xmit
nf_tables_api.o: changed function: nf_tables_bind_set
nf_tables_api.o: changed function: nf_tables_deactivate_flowtable
nf_tables_api.o: changed function: nf_tables_deactivate_set
nf_tables_api.o: changed function: nf_tables_newrule
nf_tables_api.o: new function: __nft_set_trans_bind
nft_byteorder.o: changed function: nft_byteorder_eval
nft_set_pipapo.o: changed function: nft_pipapo_remove

[ppc64le]:
cls_flower.o: changed function: fl_set_geneve_opt
cls_fw.o: changed function: fw_set_parms
ipvlan_core.o: changed function: ipvlan_process_v6_outbound
ipvlan_core.o: changed function: ipvlan_queue_xmit
nf_tables_api.o: changed function: nf_tables_deactivate_flowtable
nf_tables_api.o: changed function: nf_tables_deactivate_set
nf_tables_api.o: changed function: nf_tables_newrule
nft_byteorder.o: changed function: nft_byteorder_eval
nft_set_pipapo.o: changed function: nft_pipapo_remove

---------------------------

Modifications:
- moves NFT_TRANS_PREPARE_ERROR definition from struct in nf_tables.h
to nf_tables_api.c as a defined value and changes switch statements
invovling NFT_TRANS_PREPARE_ERROR to evaluate the passed value(s) as an
integer rather than an enumerated value

- adds __attribute__((optimize("-fno-optimize-sibling-calls"))) to
nf_tables_deactivate_set()

commit 0e8f5951ff2fc48e1b69e74657a3c47b7193c6b6
Author: Phil Sutter <psutter@redhat.com>
Date:   Wed Jun 21 18:24:52 2023 +0200

    netfilter: nf_tables: incorrect error path handling with NFT_MSG_NEWRULE

    Bugzilla: https://bugzilla.redhat.com/2216165
    CVE: CVE-2023-3390
    Y-Commit: 22b59cba347af1eea74a11bd93ab702d31c40dba

    O-Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=2214963
    Upstream Status: commit 1240eb93f0616
    O-CVE: CVE-2023-3390

    commit 1240eb93f0616b21c675416516ff3d74798fdc97
    Author: Pablo Neira Ayuso <pablo@netfilter.org>
    Date:   Thu Jun 8 02:32:02 2023 +0200

        netfilter: nf_tables: incorrect error path handling with NFT_MSG_NEWRULE

        In case of error when adding a new rule that refers to an anonymous set,
        deactivate expressions via NFT_TRANS_PREPARE state, not NFT_TRANS_RELEASE.
        Thus, the lookup expression marks anonymous sets as inactive in the next
        generation to ensure it is not reachable in this transaction anymore and
        decrement the set refcount as introduced by c1592a89942e ("netfilter:
        nf_tables: deactivate anonymous set from preparation phase"). The abort
        step takes care of undoing the anonymous set.

        This is also consistent with rule deletion, where NFT_TRANS_PREPARE is
        used. Note that this error path is exercised in the preparation step of
        the commit protocol. This patch replaces nf_tables_rule_release() by the
        deactivate and destroy calls, this time with NFT_TRANS_PREPARE.

        Due to this incorrect error handling, it is possible to access a
        dangling pointer to the anonymous set that remains in the transaction
        list.

        [1009.379054] BUG: KASAN: use-after-free in nft_set_lookup_global+0x147/0x1a0 [nf_tables]
        [1009.379106] Read of size 8 at addr ffff88816c4c8020 by task nft-rule-add/137110
        [1009.379116] CPU: 7 PID: 137110 Comm: nft-rule-add Not tainted 6.4.0-rc4+ #256
        [1009.379128] Call Trace:
        [1009.379132]  <TASK>
        [1009.379135]  dump_stack_lvl+0x33/0x50
        [1009.379146]  ? nft_set_lookup_global+0x147/0x1a0 [nf_tables]
        [1009.379191]  print_address_description.constprop.0+0x27/0x300
        [1009.379201]  kasan_report+0x107/0x120
        [1009.379210]  ? nft_set_lookup_global+0x147/0x1a0 [nf_tables]
        [1009.379255]  nft_set_lookup_global+0x147/0x1a0 [nf_tables]
        [1009.379302]  nft_lookup_init+0xa5/0x270 [nf_tables]
        [1009.379350]  nf_tables_newrule+0x698/0xe50 [nf_tables]
        [1009.379397]  ? nf_tables_rule_release+0xe0/0xe0 [nf_tables]
        [1009.379441]  ? kasan_unpoison+0x23/0x50
        [1009.379450]  nfnetlink_rcv_batch+0x97c/0xd90 [nfnetlink]
        [1009.379470]  ? nfnetlink_rcv_msg+0x480/0x480 [nfnetlink]
        [1009.379485]  ? __alloc_skb+0xb8/0x1e0
        [1009.379493]  ? __alloc_skb+0xb8/0x1e0
        [1009.379502]  ? entry_SYSCALL_64_after_hwframe+0x46/0xb0
        [1009.379509]  ? unwind_get_return_address+0x2a/0x40
        [1009.379517]  ? write_profile+0xc0/0xc0
        [1009.379524]  ? avc_lookup+0x8f/0xc0
        [1009.379532]  ? __rcu_read_unlock+0x43/0x60

        Fixes: 958bee14d071 ("netfilter: nf_tables: use new transaction infrastructure to handle sets")
        Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

    Signed-off-by: Phil Sutter <psutter@redhat.com>
    Signed-off-by: Lucas Zampieri <lzampier@redhat.com>

commit ba3c5ba6409d7607eaea6263a3d0662b69df3db4
Author: Phil Sutter <psutter@redhat.com>
Date:   Wed Jun 28 13:10:28 2023 +0200

    netfilter: nf_tables: add NFT_TRANS_PREPARE_ERROR to deal with bound set/chain

    Bugzilla: https://bugzilla.redhat.com/2216165
    CVE: CVE-2023-3390
    Y-Commit: 149b530a7ec3a6f2b8820e5d0beb4bfb3df6e2ac

    O-Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=2214963
    Upstream Status: commit 26b5a5712eb85
    O-CVE: CVE-2023-3390
    Conflicts: Dropped all chunks related to bound chains, RHEL8 does not
               support NFT_CHAIN_BINDING.

    commit 26b5a5712eb85e253724e56a54c17f8519bd8e4e
    Author: Pablo Neira Ayuso <pablo@netfilter.org>
    Date:   Fri Jun 16 14:45:26 2023 +0200

        netfilter: nf_tables: add NFT_TRANS_PREPARE_ERROR to deal with bound set/chain

        Add a new state to deal with rule expressions deactivation from the
        newrule error path, otherwise the anonymous set remains in the list in
        inactive state for the next generation. Mark the set/chain transaction
        as unbound so the abort path releases this object, set it as inactive in
        the next generation so it is not reachable anymore from this transaction
        and reference counter is dropped.

        Fixes: 1240eb93f061 ("netfilter: nf_tables: incorrect error path handling with NFT_MSG_NEWRULE")
        Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

    Signed-off-by: Phil Sutter <psutter@redhat.com>
    Signed-off-by: Lucas Zampieri <lzampier@redhat.com>

commit 4dc6ecd4d5fd0dc2e3cf4b957aad44dc99df5271
Author: Phil Sutter <psutter@redhat.com>
Date:   Wed Jun 28 13:11:38 2023 +0200

    netfilter: nf_tables: unbind non-anonymous set if rule construction fails

    Bugzilla: https://bugzilla.redhat.com/2216165
    CVE: CVE-2023-3390
    Y-Commit: bf69afff938a80f5027ce8f4b868671f84204e2d

    O-Bugzilla: https://bugzilla.redhat.com/show_bug.cgi?id=2214963
    Upstream Status: commit 3e70489721b6c
    O-CVE: CVE-2023-3390

    commit 3e70489721b6c870252c9082c496703677240f53
    Author: Pablo Neira Ayuso <pablo@netfilter.org>
    Date:   Mon Jun 26 00:42:18 2023 +0200

        netfilter: nf_tables: unbind non-anonymous set if rule construction fails

        Otherwise a dangling reference to a rule object that is gone remains
        in the set binding list.

        Fixes: 26b5a5712eb8 ("netfilter: nf_tables: add NFT_TRANS_PREPARE_ERROR to deal with bound set/chain")
        Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

    Signed-off-by: Phil Sutter <psutter@redhat.com>
    Signed-off-by: Lucas Zampieri <lzampier@redhat.com>

Signed-off-by: Ryan Sullivan <rysulliv@redhat.com>
---
 net/netfilter/nf_tables_api.c | 36 +++++++++++++++++++++++++++++------
 1 file changed, 30 insertions(+), 6 deletions(-)

diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index c7d98b011cd6..1aea2cd648d6 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -27,6 +27,7 @@
 #include <net/sock.h>
 
 #define NFT_MODULE_AUTOLOAD_LIMIT (MODULE_NAME_LEN - sizeof("nft-expr-255-"))
+#define NFT_TRANS_PREPARE_ERROR 10
 
 static LIST_HEAD(nf_tables_expressions);
 static LIST_HEAD(nf_tables_objects);
@@ -172,7 +173,8 @@ static void nft_trans_destroy(struct nft_trans *trans)
 	kfree(trans);
 }
 
-static void nft_set_trans_bind(const struct nft_ctx *ctx, struct nft_set *set)
+static void __nft_set_trans_bind(const struct nft_ctx *ctx, struct nft_set *set,
+				 bool bind)
 {
 	struct net *net = ctx->net;
 	struct nft_trans *trans;
@@ -184,16 +186,26 @@ static void nft_set_trans_bind(const struct nft_ctx *ctx, struct nft_set *set)
 		switch (trans->msg_type) {
 		case NFT_MSG_NEWSET:
 			if (nft_trans_set(trans) == set)
-				nft_trans_set_bound(trans) = true;
+				nft_trans_set_bound(trans) = bind;
 			break;
 		case NFT_MSG_NEWSETELEM:
 			if (nft_trans_elem_set(trans) == set)
-				nft_trans_elem_set_bound(trans) = true;
+				nft_trans_elem_set_bound(trans) = bind;
 			break;
 		}
 	}
 }
 
+static void nft_set_trans_bind(const struct nft_ctx *ctx, struct nft_set *set)
+{
+	return __nft_set_trans_bind(ctx, set, true);
+}
+
+static void nft_set_trans_unbind(const struct nft_ctx *ctx, struct nft_set *set)
+{
+	return __nft_set_trans_bind(ctx, set, false);
+}
+
 static int nft_netdev_register_hooks(struct net *net,
 				     struct list_head *hook_list)
 {
@@ -3260,7 +3272,8 @@ static int nf_tables_newrule(struct net *net, struct sock *nlsk,
 	if (flow)
 		nft_flow_rule_destroy(flow);
 err_release_rule:
-	nf_tables_rule_release(&ctx, rule);
+	nft_rule_expr_deactivate(&ctx, rule, NFT_TRANS_PREPARE_ERROR);
+	nf_tables_rule_destroy(&ctx, rule);
 err_release_expr:
 	for (i = 0; i < n; i++) {
 		if (info[i].ops) {
@@ -4443,11 +4456,21 @@ void nf_tables_activate_set(const struct nft_ctx *ctx, struct nft_set *set)
 }
 EXPORT_SYMBOL_GPL(nf_tables_activate_set);
 
+__attribute__((optimize("-fno-optimize-sibling-calls")))
 void nf_tables_deactivate_set(const struct nft_ctx *ctx, struct nft_set *set,
 			      struct nft_set_binding *binding,
 			      enum nft_trans_phase phase)
 {
-	switch (phase) {
+	switch ((int)phase) {
+	case NFT_TRANS_PREPARE_ERROR:
+		nft_set_trans_unbind(ctx, set);
+		if (nft_set_is_anonymous(set))
+			nft_deactivate_next(ctx->net, set);
+		else
+			list_del_rcu(&binding->list);
+
+		set->use--;
+		break;
 	case NFT_TRANS_PREPARE:
 		if (nft_set_is_anonymous(set))
 			nft_deactivate_next(ctx->net, set);
@@ -6556,7 +6579,8 @@ void nf_tables_deactivate_flowtable(const struct nft_ctx *ctx,
 				    struct nft_flowtable *flowtable,
 				    enum nft_trans_phase phase)
 {
-	switch (phase) {
+	switch ((int)phase) {
+	case NFT_TRANS_PREPARE_ERROR:
 	case NFT_TRANS_PREPARE:
 	case NFT_TRANS_ABORT:
 	case NFT_TRANS_RELEASE:
-- 
2.41.0

